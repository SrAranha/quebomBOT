import { LoggerOptions } from '@d-fischer/logger';
import TwitchClient, { HelixBanEvent, HelixExtensionTransaction, HelixFollow, HelixModeratorEvent, HelixStream, HelixSubscriptionEvent, HelixUser, UserIdResolvable } from 'twitch';
import ConnectionAdapter from './Adapters/ConnectionAdapter';
import { WebHookListenerConfig } from './Adapters/LegacyAdapter';
import ConnectCompatibleApp from './ConnectCompatibleApp';
import BanEventSubscription from './Subscriptions/BanEventSubscription';
import ExtensionTransactionSubscription from './Subscriptions/ExtensionTransactionSubscription';
import FollowsFromUserSubscription from './Subscriptions/FollowsFromUserSubscription';
import FollowsToUserSubscription from './Subscriptions/FollowsToUserSubscription';
import ModeratorEventSubscription from './Subscriptions/ModeratorEventSubscription';
import StreamChangeSubscription from './Subscriptions/StreamChangeSubscription';
import SubscriptionEventSubscription from './Subscriptions/SubscriptionEventSubscription';
import UserChangeSubscription from './Subscriptions/UserChangeSubscription';
/**
 * Certificate data used to make the listener server SSL capable.
 */
export interface WebHookListenerCertificateConfig {
    /**
     * The private key of your SSL certificate.
     */
    key: string;
    /**
     * Your SSL certificate.
     */
    cert: string;
}
/**
 * The configuration of a WebHook listener.
 */
export interface WebHookConfig {
    /**
     * Default validity of a WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    hookValidity?: number;
    /**
     * Options to pass to the logger.
     */
    logger?: Partial<LoggerOptions>;
}
/**
 * A WebHook listener you can track changes in various channel and user data with.
 */
export default class WebHookListener {
    private _server?;
    private readonly _subscriptions;
    /** @private */ readonly _twitchClient: TwitchClient;
    private readonly _adapter;
    private readonly _logger;
    private readonly _hookValidity?;
    /**
     * Creates a new WebHook listener.
     *
     * @deprecated Use the normal constructor instead.
     *
     * @param twitchClient The TwitchClient instance to use for user info and API requests.
     * @param config
     */
    static create(twitchClient: TwitchClient, config?: WebHookListenerConfig): Promise<WebHookListener>;
    /**
     * Creates a new WebHook listener.
     *
     * @param twitchClient The TwitchClient instance to use for user info and API requests.
     * @param adapter The connection adapter.
     * @param config
     */
    constructor(twitchClient: TwitchClient, adapter: ConnectionAdapter, config?: WebHookConfig);
    /**
     * Starts the backing server and listens to incoming WebHook notifications.
     */
    listen(): Promise<void>;
    /**
     * Stops the backing server, suspending all active subscriptions.
     */
    unlisten(): Promise<void>;
    /**
     * Applies middleware that handles WebHooks to a connect-compatible app (like express).
     *
     * @param app The app the middleware should be applied to.
     */
    applyMiddleware(app: ConnectCompatibleApp): void;
    /**
     * Subscribes to events representing a user changing a public setting or their email address.
     *
     * @param user The user for which to get notifications about changing a setting.
     * @param handler The function that will be called for any new notifications.
     * @param withEmail Whether to subscribe to email address changes. This requires an additional scope (user:read:email).
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToUserChanges(user: UserIdResolvable, handler: (user: HelixUser) => void, withEmail?: boolean, validityInSeconds?: number | undefined): Promise<UserChangeSubscription>;
    /**
     * Subscribes to events representing a user being followed by other users.
     *
     * @param user The user for which to get notifications about the users they will be followed by.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToFollowsToUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<FollowsToUserSubscription>;
    /**
     * Subscribes to events representing a user following other users.
     *
     * @param user The user for which to get notifications about the users they will follow.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToFollowsFromUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<FollowsFromUserSubscription>;
    /**
     * Subscribes to events representing a stream changing, i.e. going live, offline or changing its title or category.
     *
     * @param user The user for which to get notifications about their streams changing.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToStreamChanges(user: UserIdResolvable, handler: (stream?: HelixStream) => void, validityInSeconds?: number | undefined): Promise<StreamChangeSubscription>;
    /**
     * Subscribes to events representing the start or end of a channel subscription.
     *
     * @param user The user for which to get notifications about subscriptions to their channel.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToSubscriptionEvents(user: UserIdResolvable, handler: (subscriptionEvent: HelixSubscriptionEvent) => void, validityInSeconds?: number | undefined): Promise<SubscriptionEventSubscription>;
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param handler The function that will be called for any new notifications.
     * @param user The user that events will be sent for. If not given, events will be sent for all users.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToBanEvents(broadcaster: UserIdResolvable, handler: (banEvent: HelixBanEvent) => void, user?: UserIdResolvable, validityInSeconds?: number | undefined): Promise<BanEventSubscription>;
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param handler The function that will be called for any new notifications.
     * @param user The user that events will be sent for. If not given, events will be sent for all users.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToModeratorEvents(broadcaster: UserIdResolvable, handler: (modEvent: HelixModeratorEvent) => void, user?: UserIdResolvable, validityInSeconds?: number | undefined): Promise<ModeratorEventSubscription>;
    /**
     * Subscribes to extension transactions.
     *
     * @param extensionId The extension ID for which to get notifications about transactions.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToExtensionTransactions(extensionId: string, handler: (transaction: HelixExtensionTransaction) => void, validityInSeconds?: number | undefined): Promise<ExtensionTransactionSubscription>;
    /** @private */
    _buildHookUrl(id: string): Promise<string>;
    /** @private */
    _changeIdOfSubscription(oldId: string, newId: string): void;
    /** @private */
    _dropSubscription(id: string): void;
    private _createHandleRequest;
    private _handleVerification;
    private _handleNotification;
}
