"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var portfinder_1 = require("@d-fischer/portfinder");
var public_ip_1 = require("@d-fischer/public-ip");
var ConnectionAdapter_1 = require("./ConnectionAdapter");
/**
 * A WebHook connection adapter to support the "old style" options.
 *
 * @deprecated Use literally *any* other connection adapter instead.
 * @hideProtected
 */
var LegacyAdapter = /** @class */ (function (_super) {
    tslib_1.__extends(LegacyAdapter, _super);
    /** @private */
    function LegacyAdapter(_config) {
        var _this = _super.call(this, _config) || this;
        _this._config = _config;
        return _this;
    }
    /**
     * Takes the legacy WebHookListenerConfig and creates a connection adapter from it.
     *
     * @expandParams
     */
    LegacyAdapter.create = function (config) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var listenerPort, _a, reverseProxy, _b, _c, _d;
            return tslib_1.__generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _a = config.port;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, portfinder_1.getPortPromise()];
                    case 1:
                        _a = (_e.sent());
                        _e.label = 2;
                    case 2:
                        listenerPort = _a;
                        reverseProxy = config.reverseProxy || {};
                        _b = LegacyAdapter.bind;
                        _c = {};
                        _d = config.hostName;
                        if (_d) return [3 /*break*/, 4];
                        return [4 /*yield*/, public_ip_1.v4()];
                    case 3:
                        _d = (_e.sent());
                        _e.label = 4;
                    case 4: return [2 /*return*/, new (_b.apply(LegacyAdapter, [void 0, (_c.hostName = _d,
                                _c.listenerPort = listenerPort,
                                _c.sslCert = config.ssl,
                                _c.connectUsingSsl = reverseProxy.ssl === undefined ? !!config.ssl : reverseProxy.ssl,
                                _c.externalPort = reverseProxy.port || listenerPort,
                                _c.pathPrefix = reverseProxy.pathPrefix,
                                _c)]))()];
                }
            });
        });
    };
    Object.defineProperty(LegacyAdapter.prototype, "connectUsingSsl", {
        /** @protected */
        get: function () {
            return this._config.connectUsingSsl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LegacyAdapter.prototype, "pathPrefix", {
        /** @protected */
        get: function () {
            return this._config.pathPrefix;
        },
        enumerable: true,
        configurable: true
    });
    /** @protected */
    LegacyAdapter.prototype.getExternalPort = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.externalPort];
            });
        });
    };
    /** @protected */
    LegacyAdapter.prototype.getHostName = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.hostName];
            });
        });
    };
    return LegacyAdapter;
}(ConnectionAdapter_1.default));
exports.default = LegacyAdapter;
module.exports = exports = LegacyAdapter;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LegacyAdapter;
